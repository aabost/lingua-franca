/**
 * Micro-benchmark from the Savina benchmark suite.
 * Intended to measure message passing overhead by stress
 * testing the mailbox of actors.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 *
 * Lacking the mailbox in the reactor model this benchmarks
 * measures message passing overhead and scheduling overhead
 * because of the necessary scheduling after each message which
 * is not necessary in the actor model.
 *
 * Informal results for 1,000,000 messages
 * on my PC with fast forward enabled:
 * Unthreaded: 178 ms
 * Threaded: 205 ms
 *
 * For comparison some informal results for 1,000,000 messages
 * on the same PC with the Savina Akka implementation:
 *
 * Threaded: 157 ms
 *
 * @author Hannes Klein
 * @Abanob Bostouros
 */

target C;


reactor ProducerReactor(countTo:int(1000000)) {


    state i:int(0); // current counter value

    input inStartCounting:bool;

	logical action outFinishedCounting;
    output outResetCounter:bool;
    output outIncrement:bool;
    output outRetrieveResult:bool;
    input inResult:int;
    logical action count;
    
    reaction(outFinishedCounting){=
        request_stop();
    =}
    

    reaction(inStartCounting) -> count, outResetCounter {=
        // reset counter
        self->i = 0;
        SET(outResetCounter, true);

        schedule(count,0);
    =}

    reaction(count) -> outIncrement, outRetrieveResult, count {=

        if(self->i < self->countTo) {
            SET(outIncrement,true);
            self->i += 1;
            schedule(count,0);
        } else {
            SET(outRetrieveResult,true);
        }
    =}

    reaction(inResult) -> outFinishedCounting {=
        if(inResult->value != self->countTo) {
            printf("ProducerReactor expected %d, found: %d",self->countTo, inResult->value);
        } else {
            printf("SUCCESS! received: %d ", inResult->value);
        }
        schedule(outFinishedCounting, 0);
    =}
}


reactor CountingReactor (numIterations:int(12)){

    input inFinishedCounting:bool;
    input inReset:bool;
    input inIncrement:bool;
    input inRetrieveResult:bool;
    output outSendResult:int;
    output outStartCounting:bool;

    state count:int(0);
    state iteration:int(0);

    reaction(inFinishedCounting) -> outStartCounting{=
        if(self->numIterations <= self->iteration)
        {
          request_stop();
        }
        else{
          self->iteration += 1;
          printf("Iteration: %d",self->iteration);
          SET(outStartCounting,true);
        }
    =}

    reaction(inReset) {=
        self->count = 0;
    =}

    reaction(inIncrement) {=
        self->count++;
    =}

    reaction(inRetrieveResult) -> outSendResult {=
        SET(outSendResult,self->count);
    =}
}

main reactor CountingBenchmark(numIterations:int(12), countTo:int(1000000)) {

    producer = new ProducerReactor(countTo = countTo);
    


    reaction(startup) -> producer.inStartCounting {=
        //printBenchmarkInfo("CountingBenchmark");
        //printArgs("numIterations", numIterations, "countTo", countTo);
        //printSystemInfo();
        SET(producer.inStartCounting,true);
    =}

    counter = new CountingReactor();

    producer.outIncrement -> counter.inIncrement;
    producer.outResetCounter -> counter.inReset;
    producer.outRetrieveResult -> counter.inRetrieveResult;
    counter.outSendResult -> producer.inResult;
}